
## 1. Создание короткой ссылки
1. Я предоставляю эндпоинт `POST /api/shorten`, куда можно отправить запрос в JSON-формате:
   - **url** — обязательная ссылка, которую требуется сократить.
   - **expDate** (опционально) — срок действия (дедлайн). Если дата указана, после неё ссылка считается просроченной.
   - **limit** (опционально) — максимально допустимое количество переходов.

2. **При первом обращении** к сервису, если у пользователя нет cookie `userUUID`, я **создаю** ему уникальный идентификатор (через `userService`) и устанавливаю куку, чтобы отличать ссылки разных пользователей.

3. В ответ я генерирую **токен** (например, `abcd123`), собираю конечную короткую ссылку вида `http://<server>:8080/<token>`, и возвращаю её в теле ответа.

Таким образом, пользователь получает **короткую ссылку** с учётом дедлайна и/или лимита, если они заданы.

---

## 2. Переход по сокращённой ссылке
Когда пользователь переходит по адресу `http://<server>:8080/<token>`, мой `RedirectController`:
1. Ищет в базе оригинальный URL по этому токену.
2. **Проверяет**, не просрочена ли ссылка (если `deadLineDate` в прошлом). Если дата просрочена, редирект не происходит — я перенаправляю на страницу ошибки.
3. Если срок не истёк, **проверяю лимит** переходов. Если лимит достигнут, тоже выдаю ошибку (или страницу недоступности).
4. Если всё в норме, **увеличиваю счётчик переходов** на +1 и делаю `redirect:` на исходный URL.

---

## 3. Удаление ссылки
Я реализовал эндпоинт `POST /api/delete-link/{id}`. Когда пользователь вызывает этот эндпоинт:
1. Я получаю идентификатор ссылки `id`.
2. Проверяю cookie `userUUID`, чтобы убедиться, что он в системе.
3. Удаляю ссылку из базы (метод `deleteLink(id)`).
4. Ссылка становится недоступной.

---

## 4. Обновление ссылки
Эндпоинт `POST /api/update-link/{id}` позволяет **обновлять** уже существующую ссылку.  
Можно изменить:
- **Токен** (проверяю, чтобы не содержал кириллицу, не превышал 8 символов).
- **Дата окончания** (продлить или установить дедлайн).
- **Лимит** переходов.
- **Сам URL**.

При этом я снова сохраняю новую конфигурацию ссылки в базе.

---

## 5. Проверка срока действия и лимита
1. **Срок действия (Expired)**:  
   - Если у ссылки есть `deadLineDate`, то при каждом редиректе я сравниваю текущую дату с `deadLineDate`. Если `LocalDate.now().isAfter(deadLineDate)`, ссылка просрочена — редирект не выполняю.
2. **Лимит (Count vs. LimitCross)**:  
   - Я храню, сколько раз ссылка была посещена (`count`), и какой у неё лимит (`limitCross`). При каждом редиректе увеличиваю `count` на 1. Если `count >= limitCross`, редирект останавливаю и перенаправляю на ошибку.

---

### Итоговая функциональность
1. **Создание**: добавляю (по желанию) дедлайн и лимит.  
2. **Редирект**: проверяю, не просрочена ли ссылка, не превышён ли лимит, и перенаправляю на исходный URL, если всё в порядке.  
3. **Удаление**: позволяю убрать ссылку из системы.  
4. **Обновление**: можно менять токен, дедлайн, лимит и URL.  
5. **Проверка** просрочки и лимита ведётся автоматически при каждом переходе.

Так пользователь может гибко управлять своими сокращёнными ссылками и контролировать срок их действия и количество доступных переходов.
